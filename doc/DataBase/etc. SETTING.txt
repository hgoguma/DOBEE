== 이벤트 스케쥴러
	-부재 / 연장근무 신청 미승인 3일이상 지속시 반려로 전환됨
	DELIMITER //
		CREATE EVENT IF NOT EXISTS UPDATE_DENY_APPLY
			ON SCHEDULE 
			EVERY 1 DAY STARTS '2020-01-30 00:00:00'
			DO
				BEGIN
					UPDATE APPLY SET ISAUTH='반려', REJREASON='승인 기한 만료' WHERE ISAUTH = '미승인' AND DATEDIFF(NOW(), REQDATE) > 5;
		        END //


	-근태 퇴근 안하고 갈 경우 해당 일의 출근 데이터 삭제
	DELIMITER //
		CREATE EVENT DELETE_ATTEND
			ON SCHEDULE EVERY 1 DAY
		    STARTS '2020-01-31 02:00:00'
		    DO
			BEGIN
				DELETE FROM ATTEND WHERE OFFTIME IS NULL;
		END //



	-매년 1월 1일 연차 초기화	27일 0일
	DELIMITER //
	CREATE EVENT IF NOT EXISTS INSERT_NEWYEAR_BREAK
		ON SCHEDULE EVERY 1 YEAR STARTS '2020-01-01 00:00:00'
		DO
			BEGIN
				UPDATE APPLY SET TOTALBREAK = 27, USEDBREAK = 0;
        		END //



== 트리거
	-유저 생성 시 연차 테이블 데이터 생성
	USER AFTER_INSERT 
		CREATE TRIGGER `user_AFTER_INSERT` AFTER INSERT ON `USER` FOR EACH ROW BEGIN
			insert into BREAK (mail, totalbreak, usedbreak) values (new.mail, 27, 0 );
		END

	-연차 사용시 사용 연차 BREAKLIST 테이블 Low 추가
	APPLY AFTER_UPDATE
		CREATE TRIGGER `apply_AFTER_UPDATE` AFTER UPDATE ON `APPLY` FOR EACH ROW BEGIN
			IF NEW.ISAUTH = '승인' AND NEW.APYCODE != 3 AND NEW.APYCODE != 4 AND NEW.APYCODE != 6 THEN
				INSERT INTO BREAKLIST (USINGBREAK, APLSEQ, MAIL) VALUES (NEW.USEBREAK, NEW.APLSEQ, NEW.DRAFTER);
			ELSEIF NEW.ISAUTH = '승인' AND NEW.APYCODE = 2 THEN
				INSERT INTO BREAKLIST (USINGBREAK, APLSEQ, MAIL) VALUES (0.5, NEW.APLSEQ, NEW.DRAFTER);
	       			UPDATE APPLY SET USINGBREAK  = 0.5 WHERE APLSEQ = OLD.APLSEQ;
    			END IF;
		END

	-연차 사용시 연차 BREAK 테이블 반영
	BREAKLIST AFTER INSERT
		CREATE DEFINER=`dobee`@`%` TRIGGER `breaklist_AFTER_INSERT` AFTER INSERT ON `breaklist` FOR EACH ROW BEGIN
			UPDATE BREAK 
			SET USEDBREAK = USEDBREAK + NEW.USINGBREAK
			WHERE MAIL = NEW.MAIL;
		END




== CASCADE 코드성 제외 모두 적용 (DELETE/UPDATE
	- sql 에서 적용할 필요 없어요. script 에 다 들어있어요
